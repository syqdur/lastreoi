// UserManagementModal.tsx - Optimierte L√∂sch-Funktionen

// ERSETZEN Sie diese beiden Funktionen in Ihrer UserManagementModal.tsx:

const deleteUser = async (userName: string, deviceId: string) => {
  const userKey = `${userName}-${deviceId}`;
  
  if (deleteConfirm !== userKey) {
    setDeleteConfirm(userKey);
    return;
  }

  setDeletingUser(userKey);
  setDeleteConfirm(null);

  try {
    console.log(`üóëÔ∏è Optimized delete for user: ${userName} (${deviceId})`);
    
    // SOFORTIGE PR√úFUNG: Ist das der aktuelle Nutzer?
    const currentUserName = localStorage.getItem('userName');
    const currentDeviceId = localStorage.getItem('deviceId');
    const isDeletingSelf = (currentUserName === userName && currentDeviceId === deviceId);
    
    if (isDeletingSelf) {
      console.log(`üö® SELF-DELETE DETECTED - Immediate logout sequence`);
      
      // Sofort kick signal setzen
      await setDoc(doc(db, 'galleries', galleryId, 'kick_signals', deviceId), {
        userName: userName,
        deviceId: deviceId,
        kickedAt: new Date().toISOString(),
        reason: 'self_deleted'
      });
      
      // Sofortiger Logout ohne auf Firebase zu warten
      localStorage.setItem('userDeleted', 'true');
      localStorage.setItem('kickReason', 'self_deleted');
      
      // Modal sofort schlie√üen
      onClose();
      
      // Sofortiger Redirect nach sehr kurzer Verz√∂gerung
      setTimeout(() => {
        localStorage.clear();
        window.location.href = '/';
      }, 100);
      
      // Firebase cleanup im Hintergrund (ohne darauf zu warten)
      deleteUserDataInBackground(userName, deviceId);
      return;
    }
    
    // F√ºr andere Nutzer: Optimierte parallele L√∂schung
    console.log(`üóëÔ∏è Deleting other user: ${userName}`);
    
    // Alle L√∂schvorg√§nge parallel starten (nicht sequenziell)
    const deletePromises = [];
    
    // 1. Live Users Query
    deletePromises.push(
      getDocs(query(collection(db, 'galleries', galleryId, 'live_users'), where('deviceId', '==', deviceId)))
        .then(snapshot => {
          const batch = writeBatch(db);
          snapshot.docs.forEach(doc => batch.delete(doc.ref));
          return batch.commit();
        })
    );
    
    // 2. User Profiles Query  
    deletePromises.push(
      getDocs(query(collection(db, 'galleries', galleryId, 'userProfiles'), where('deviceId', '==', deviceId)))
        .then(snapshot => {
          const batch = writeBatch(db);
          snapshot.docs.forEach(doc => batch.delete(doc.ref));
          return batch.commit();
        })
    );
    
    // 3. Media Query
    deletePromises.push(
      getDocs(query(collection(db, 'galleries', galleryId, 'media'), where('deviceId', '==', deviceId)))
        .then(snapshot => {
          const batch = writeBatch(db);
          snapshot.docs.forEach(doc => batch.delete(doc.ref));
          return batch.commit();
        })
    );
    
    // 4. Comments Query
    deletePromises.push(
      getDocs(query(collection(db, 'galleries', galleryId, 'comments'), where('deviceId', '==', deviceId)))
        .then(snapshot => {
          const batch = writeBatch(db);
          snapshot.docs.forEach(doc => batch.delete(doc.ref));
          return batch.commit();
        })
    );
    
    // 5. Likes Query
    deletePromises.push(
      getDocs(query(collection(db, 'galleries', galleryId, 'likes'), where('deviceId', '==', deviceId)))
        .then(snapshot => {
          const batch = writeBatch(db);
          snapshot.docs.forEach(doc => batch.delete(doc.ref));
          return batch.commit();
        })
    );
    
    // 6. Stories Query
    deletePromises.push(
      getDocs(query(collection(db, 'galleries', galleryId, 'stories'), where('deviceId', '==', deviceId)))
        .then(snapshot => {
          const batch = writeBatch(db);
          snapshot.docs.forEach(doc => batch.delete(doc.ref));
          return batch.commit();
        })
    );
    
    // 7. Kick Signal
    deletePromises.push(
      setDoc(doc(db, 'galleries', galleryId, 'kick_signals', deviceId), {
        userName: userName,
        deviceId: deviceId,
        kickedAt: new Date().toISOString(),
        reason: 'deleted_by_admin'
      })
    );
    
    // Alle L√∂schvorg√§nge parallel ausf√ºhren
    await Promise.all(deletePromises);
    
    console.log(`‚úÖ Successfully deleted user: ${userName}`);
    
    // Reload user data
    await loadUserData();
    
  } catch (error) {
    console.error('‚ùå Error deleting user:', error);
    setError('Fehler beim L√∂schen des Benutzers');
  } finally {
    setDeletingUser(null);
  }
};

// Neue Hintergrund-L√∂schfunktion f√ºr Self-Delete
const deleteUserDataInBackground = async (userName: string, deviceId: string) => {
  try {
    console.log(`üßπ Background cleanup for self-deleted user: ${userName}`);
    
    const deletePromises = [
      // Live Users
      getDocs(query(collection(db, 'galleries', galleryId, 'live_users'), where('deviceId', '==', deviceId)))
        .then(snapshot => {
          const batch = writeBatch(db);
          snapshot.docs.forEach(doc => batch.delete(doc.ref));
          return batch.commit();
        }),
      
      // User Profiles
      getDocs(query(collection(db, 'galleries', galleryId, 'userProfiles'), where('deviceId', '==', deviceId)))
        .then(snapshot => {
          const batch = writeBatch(db);
          snapshot.docs.forEach(doc => batch.delete(doc.ref));
          return batch.commit();
        }),
      
      // Media
      getDocs(query(collection(db, 'galleries', galleryId, 'media'), where('deviceId', '==', deviceId)))
        .then(snapshot => {
          const batch = writeBatch(db);
          snapshot.docs.forEach(doc => batch.delete(doc.ref));
          return batch.commit();
        }),
      
      // Comments
      getDocs(query(collection(db, 'galleries', galleryId, 'comments'), where('deviceId', '==', deviceId)))
        .then(snapshot => {
          const batch = writeBatch(db);
          snapshot.docs.forEach(doc => batch.delete(doc.ref));
          return batch.commit();
        }),
      
      // Likes
      getDocs(query(collection(db, 'galleries', galleryId, 'likes'), where('deviceId', '==', deviceId)))
        .then(snapshot => {
          const batch = writeBatch(db);
          snapshot.docs.forEach(doc => batch.delete(doc.ref));
          return batch.commit();
        }),
      
      // Stories
      getDocs(query(collection(db, 'galleries', galleryId, 'stories'), where('deviceId', '==', deviceId)))
        .then(snapshot => {
          const batch = writeBatch(db);
          snapshot.docs.forEach(doc => batch.delete(doc.ref));
          return batch.commit();
        })
    ];
    
    await Promise.all(deletePromises);
    console.log(`‚úÖ Background cleanup completed for: ${userName}`);
    
  } catch (error) {
    console.warn('‚ö†Ô∏è Background cleanup failed (but user was already logged out):', error);
  }
};

const bulkDeleteUsers = async () => {
  if (!showBulkConfirm) {
    setShowBulkConfirm(true);
    return;
  }

  setBulkDeleting(true);
  setShowBulkConfirm(false);

  try {
    console.log(`üóëÔ∏è Optimized bulk delete for ${selectedUsers.size} users...`);
    
    const currentUserName = localStorage.getItem('userName');
    const currentDeviceId = localStorage.getItem('deviceId');
    let isSelfIncluded = false;
    
    // Pr√ºfen ob current user in der Auswahl ist
    for (const userKey of Array.from(selectedUsers)) {
      const deviceId = userKey.slice(-36);
      const userName = userKey.slice(0, -37);
      
      if (currentUserName === userName && currentDeviceId === deviceId) {
        isSelfIncluded = true;
        console.log(`üö® SELF-DELETE in bulk selection detected`);
        break;
      }
    }
    
    if (isSelfIncluded) {
      // Sofortiger Logout bei Self-Delete in Bulk
      await setDoc(doc(db, 'galleries', galleryId, 'kick_signals', currentDeviceId), {
        userName: currentUserName,
        deviceId: currentDeviceId,
        kickedAt: new Date().toISOString(),
        reason: 'bulk_self_deleted'
      });
      
      localStorage.setItem('userDeleted', 'true');
      localStorage.setItem('kickReason', 'bulk_self_deleted');
      
      onClose();
      
      setTimeout(() => {
        localStorage.clear();
        window.location.href = '/';
      }, 100);
      
      // Bulk cleanup im Hintergrund
      bulkDeleteInBackground(Array.from(selectedUsers));
      return;
    }
    
    // Normale Bulk-L√∂schung ohne Self-Delete
    const deletePromises = [];
    
    for (const userKey of Array.from(selectedUsers)) {
      const deviceId = userKey.slice(-36);
      const userName = userKey.slice(0, -37);
      
      console.log(`üóëÔ∏è Processing bulk delete: ${userName}`);
      
      // Kick signal
      deletePromises.push(
        setDoc(doc(db, 'galleries', galleryId, 'kick_signals', deviceId), {
          userName: userName,
          deviceId: deviceId,
          kickedAt: new Date().toISOString(),
          reason: 'bulk_deleted_by_admin'
        })
      );
      
      // Parallele L√∂schung f√ºr jeden User
      deletePromises.push(
        Promise.all([
          getDocs(query(collection(db, 'galleries', galleryId, 'live_users'), where('deviceId', '==', deviceId)))
            .then(snapshot => {
              const batch = writeBatch(db);
              snapshot.docs.forEach(doc => batch.delete(doc.ref));
              return batch.commit();
            }),
          
          getDocs(query(collection(db, 'galleries', galleryId, 'userProfiles'), where('deviceId', '==', deviceId)))
            .then(snapshot => {
              const batch = writeBatch(db);
              snapshot.docs.forEach(doc => batch.delete(doc.ref));
              return batch.commit();
            }),
          
          getDocs(query(collection(db, 'galleries', galleryId, 'media'), where('deviceId', '==', deviceId)))
            .then(snapshot => {
              const batch = writeBatch(db);
              snapshot.docs.forEach(doc => batch.delete(doc.ref));
              return batch.commit();
            }),
          
          getDocs(query(collection(db, 'galleries', galleryId, 'comments'), where('deviceId', '==', deviceId)))
            .then(snapshot => {
              const batch = writeBatch(db);
              snapshot.docs.forEach(doc => batch.delete(doc.ref));
              return batch.commit();
            }),
          
          getDocs(query(collection(db, 'galleries', galleryId, 'likes'), where('deviceId', '==', deviceId)))
            .then(snapshot => {
              const batch = writeBatch(db);
              snapshot.docs.forEach(doc => batch.delete(doc.ref));
              return batch.commit();
            }),
          
          getDocs(query(collection(db, 'galleries', galleryId, 'stories'), where('deviceId', '==', deviceId)))
            .then(snapshot => {
              const batch = writeBatch(db);
              snapshot.docs.forEach(doc => batch.delete(doc.ref));
              return batch.commit();
            })
        ])
      );
    }
    
    // Alle L√∂schvorg√§nge parallel ausf√ºhren
    await Promise.all(deletePromises);
    
    console.log(`‚úÖ Bulk deletion completed successfully`);
    
    // Clear selection and reload data
    setSelectedUsers(new Set());
    await loadUserData();
    
  } catch (error) {
    console.error('‚ùå Error in bulk delete:', error);
    setError('Fehler beim L√∂schen der Benutzer');
  } finally {
    setBulkDeleting(false);
  }
};

// Hintergrund Bulk-Delete Funktion
const bulkDeleteInBackground = async (userKeys: string[]) => {
  try {
    console.log(`üßπ Background bulk cleanup for ${userKeys.length} users...`);
    
    const deletePromises = [];
    
    for (const userKey of userKeys) {
      const deviceId = userKey.slice(-36);
      const userName = userKey.slice(0, -37);
      
      deletePromises.push(
        Promise.all([
          getDocs(query(collection(db, 'galleries', galleryId, 'live_users'), where('deviceId', '==', deviceId)))
            .then(snapshot => {
              const batch = writeBatch(db);
              snapshot.docs.forEach(doc => batch.delete(doc.ref));
              return batch.commit();
            }),
          
          getDocs(query(collection(db, 'galleries', galleryId, 'userProfiles'), where('deviceId', '==', deviceId)))
            .then(snapshot => {
              const batch = writeBatch(db);
              snapshot.docs.forEach(doc => batch.delete(doc.ref));
              return batch.commit();
            }),
          
          getDocs(query(collection(db, 'galleries', galleryId, 'media'), where('deviceId', '==', deviceId)))
            .then(snapshot => {
              const batch = writeBatch(db);
              snapshot.docs.forEach(doc => batch.delete(doc.ref));
              return batch.commit();
            }),
          
          getDocs(query(collection(db, 'galleries', galleryId, 'comments'), where('deviceId', '==', deviceId)))
            .then(snapshot => {
              const batch = writeBatch(db);
              snapshot.docs.forEach(doc => batch.delete(doc.ref));
              return batch.commit();
            }),
          
          getDocs(query(collection(db, 'galleries', galleryId, 'likes'), where('deviceId', '==', deviceId)))
            .then(snapshot => {
              const batch = writeBatch(db);
              snapshot.docs.forEach(doc => batch.delete(doc.ref));
              return batch.commit();
            }),
          
          getDocs(query(collection(db, 'galleries', galleryId, 'stories'), where('deviceId', '==', deviceId)))
            .then(snapshot => {
              const batch = writeBatch(db);
              snapshot.docs.forEach(doc => batch.delete(doc.ref));
              return batch.commit();
            })
        ])
      );
    }
    
    await Promise.all(deletePromises);
    console.log(`‚úÖ Background bulk cleanup completed`);
    
  } catch (error) {
    console.warn('‚ö†Ô∏è Background bulk cleanup failed (but users were already logged out):', error);
  }
};